# Laravel

PHP Backend Framework

## File structure

Laravel imposes almost no restrictions for class location. As long as Composer can autoload the class.

### `.env`

Configuration file dependent on which machine is running

- **DO NOT COMMIT**
  - contains sensitive data
- MAIL_MAILER
  - = log: write emails to `storage/logs/laravel.log`

### `/app`

Core code of application

#### `/app/broadcasting/`

Channels and [event broadcasting](https://laravel.com/docs/12.x/broadcasting)

#### `/app/console/`

Custom Artisan Command classes

#### `/app/events/`

[Event classes](https://laravel.com/docs/12.x/events) that alert other parts of application that a given action has occurred 

#### `/app/exceptions/`

Custom exceptions

#### `/app/http/`

Controllers, middleware, and form requests

All the logic to handle requests

#### `/app/jobs/`

[Queueable jobs](https://laravel.com/docs/12.x/queues) from application or synchronously ran

#### `/app/listeners/`

Classes that handle [events](https://laravel.com/docs/12.x/events)

Event listener receive an event instance and perform logic when the event is fired

ex. `UserRegistered` event handled by a `SendWelcomeEmail` listener

#### `/app/mail/`

Classes that represent [emails](https://laravel.com/docs/12.x/mail) sent by app

Mail object used for building an email that is sent with `Mail::send`

#### `/app/models/`

[Eloquent ORM Entities](https://laravel.com/docs/12.x/eloquent)

i.e. Database Table represented by a Class (ORM)

#### `/app/notifications/`

"Transaction" [notifications](https://laravel.com/docs/12.x/notifications) that are sent by your application

Features abstract sending notifications over a variety of drivers such as email, Slack, SMS, or stored in a database

#### `/app/policies/`

[Authorization Policy classes](https://laravel.com/docs/12.x/authorization)

Used to determine if a user can perform a given action against a resource

#### `/app/providers/`

[Service providers](https://laravel.com/docs/12.x/providers) that bootstrap your application by binding services in the service container, registering events, or performing any other tasks to **prepare** your application for incoming requests

#### `/app/rules/`

Custom [validation](https://laravel.com/docs/12.x/validation) rule objects

Rules encapsulate complicated validation logic

### `/boostrap`

Contains `app.php` which bootstraps the framework

#### `/bootstrap/cache/`

Framework generated files for performance optimization such as the route and services cache files

### `/config`

All of the configuration files

They can all be deleted because the default values exist in `vendor/` and Laravel's core

#### `/config/app.php`

- `timezone`
- `locale`

### `/routes`

route definitions

#### `/routes/web.php`

Web Routes

Routes that belong to the `web` middleware group
- provides session state, CSRF protection, and cookie encryption

#### `/routes/api.php`

REST endpoints

Stateless routes that are authenticated via [tokens](https://laravel.com/docs/12.x/sanctum)
- no access to session state

Install additional route files for API routes with `php artisan install:api`

#### `/routes/channels.php`

You may register all of the [event broadcasting](https://laravel.com/docs/12.x/broadcasting) channels that your application supports

#### `/routes/console.php`

Closure-based console commands

Console based entry points (routes) into the application.

Can [schedule](https://laravel.com/docs/12.x/scheduling) tasks.

### `/database`

database migrations, model factories, and seeds

Can hold a SQLLite database

#### `/database/migrations/`

Database migrations

### `/public`

`index.php`, which is the entry point for all requests
- configures autoloading
  
assets
- images
- javascript
- css

### `/resources`

Frontend Files like views and raw, un-compiled assets (javascript and css)

- Blade
- CSS
- JS

#### `/resources/views/`

Blade(HTML) frontend files

### `/storage`

Contains your logs, compiled Blade templates, file based sessions, file caches, and other files generated by the framework.

### `/tests`

automated tests

### `/vendor`

Composer dependencies

## Run

Once the application has been created, you can start Laravel's local development server, queue worker, and Vite development server using the dev Composer script:

➜ cd example-app
➜ npm install && npm run build
➜ composer run dev

## Use Cases

1. Full Stack
   - route requests
   - render frontend
2. API
   - authentication
   - data storage / retrieval
   - [routing](https://laravel.com/docs/12.x/routing)
   - [Laravel Sanctum](https://laravel.com/docs/12.x/sanctum)
   - [Eloquent ORM](https://laravel.com/docs/12.x/eloquent)
   - Migration: creates the projects table so API has data.
   - Factory + Seeder: generates dummy content quickly to work with UI.
   - API Resource & Controller: standard REST endpoints for CRUD; Next.js fetches these.
   - CORS: allows the Next.js frontend to call the Laravel API during dev.
   - getServerSideProps: fetches data on server-side so pages load with content and SEO-friendly.
   - Bootstrap: gives pre-built responsive components so UI looks good quickly.
   - Contact endpoint logging: safe way to validate form work before adding email provider.
   - Add image upload (Laravel file storage + S3).
   - Add Authentication with Laravel Sanctum (protect create/update).
   - Use Next.js API routes as proxy if you prefer to avoid CORS config.
   - Deploy: Laravel on a VPS / Laravel Vapor / Render; Next.js on Vercel.
   - Add resume download, social links, meta tags and og:image for social sharing.
   - Keep API responses predictable (use resources/transformers for consistent JSON).
   - Start small: get index -> project details -> contact working, then add editing or auth.
   - Use your Symfony knowledge: routing/controllers/models map nicely to Laravel equivalents.

## AI

[Boost](https://github.com/laravel/boost)

## [Request Lifecycle](https://laravel.com/docs/12.x/lifecycle)

1. Entry point for all requests is the `public/index.php`

- Web server (ex. Apache/Nginx) sends all requests here
- Loads composer generated autoloader definition, and then retrieves instance of Laravel application from `bootstrap/app.php`

2. Request sent to HTTP kernel or the console kernel for bootstrapping and service provider registering
   1. HTTP Kernel
      - `handleRequest()`
   2. console kernel
      - `handleCommand()`
- Kernel is Big black box that takes in HTTP Requests and returns HTTP Responses
- Array of bootstrappers defined to run before request. Configures error handling, logging, [detect application environment](https://laravel.com/docs/12.x/configuration#environment-configuration), and more.
- Also passes the request through the application's **middleware** stack which handle reading and writing the [HTTP session](https://laravel.com/docs/12.x/session), check if in maintenance mode, [verify CSRF token](https://laravel.com/docs/12.x/csrf), and more.
- One of the most important kernel bootstrapping actions is loading the [service providers](https://laravel.com/docs/12.x/providers). Service providers bootstrap framework's various components (database, queue, validation, and routing). Laravel will instantiate, `register()`, and then `boot()` each provider, so each provider may depend on every container binding being available by the time their `boot()` is executed.

3. Kernel hands off the `Request` to the **router** 

- Router dispatches to a route or controller method and runs route specific [middleware](https://laravel.com/docs/12.x/middleware)
- Middleware will filter / examine HTTP requests entering application
- After passing through middleware, the route / controller method will be executed and the `Response` returned

4. `Response` returns through chain of middleware to the kernel method

- Middleware has a chance to modify or examine outgoing response
- After the middleware, it will return back to the kernel's `handle` method which will call the `Response`'s `send()` method

### Focus on Service Providers

Service providers are classes that tell Laravel how to load and use the features your app needs.

They register things like services, event listeners, routes, and more.

Service providers are the key to bootstrapping (setting up everything needed) a Laravel application.

1. Application instance created
2. Service providers registered
3. Request handed to the bootstrapped application

How Service Providers and Service Containers work together:
1. **Application boots up**: Laravel starts by loading all service providers listed in your config/app.php file.
2. **Providers register bindings**: Each service provider's register() method is called. This is where you tell the service container how to build your classes. For example, you might bind an interface to a specific implementation.
3. **Container resolves dependencies**: Later, when your code needs a specific service (for example, a controller needs a PaymentGateway class), the service container looks up the instructions provided by a service provider. It then builds and injects the appropriate class, including any of its dependencies. 

Application's user-defined service providers are stored in the `app/Providers` directory

`AppServiceProvider` is fairly empty, good place to add your application's own bootstrapping and service container bindings.

## [Configuration](https://laravel.com/docs/12.x/configuration)

All configuration files in `config/`

To give your application a speed boost, you should cache all of your config files into a single file using `config:cache` Artisan command. 
- (Tip: run during production deployment process)
- Once the configuration has been cached, your application's `.env` file will not be loaded by the framework. So only call `env` function from within your app's `config` files. Otherwise calling the `env` function will only return external, system level environment variables.
- Purge cached configuration with `$ php artisan config:clear`


Access config values from anywhere with `config()` [function](https://laravel.com/docs/12.x/configuration#accessing-configuration-values)

Most of Laravel's configuration files are already published in your application's `config` directory, but not all.
- Certain configs (ex. `cors.php` and `view.php`) are not published by default because most apps wont modify them

## [Service Provider](https://laravel.com/docs/12.x/providers)

Class that registers or "binds" services, interfaces, and other components into the service container.

- i.e. Puts things into the service container. Service container will manage and provide those things when needed
- Service providers are the central place for all application bootstrapping. During the application's startup, Laravel cycles through all the registered service providers, runs their `register()` methods, and then their `boot()` methods
- i.e. sets up an object so the container can use it

## [Service Container](https://laravel.com/docs/12.x/container)

Manages class dependencies and performs dependency injection

- Dependency injection is when the class dependencies are "injected" into the class via the constructor or "setter" methods
  - instead of using `new` you inject dependencies in and let the container control creating them (IoC - Inversion of control)

## [Facades](https://laravel.com/docs/12.x/facades)

Provides a "static" interface to classes that are available in the application's [service container](https://laravel.com/docs/12.x/container)

Service Container	
- Role: Manages class instantiation and dependencies.	
- When it is used?: When an object or dependency needs to be resolved and injected, either automatically or manually.

Service Provider
-	Role: "Teaches" the service container how to build specific classes by binding them.
- When is it used?: During the application's bootstrapping phase to register bindings in the service container.

Facade
- Role:	Provides a static interface for accessing a class that is already in the service container.	
- When is it used?: For quick, simple access to a service without needing to manually inject it.

Be careful not to over rely on Facades i.e. "scope creep" and defeat the purpose of classes having a single use

## [Helper](https://laravel.com/docs/12.x/helpers)

Global "helper functions" that make it even easier to interact with common Laravel features

Common ones:
- `view`
- `response`
- `url`
- `config`

ex. Facade vs Helper
```php
use Illuminate\Support\Facades\Response;
 
Route::get('/users', function () {
    return Response::json([
        // ...
    ]);
});
 
Route::get('/users', function () {
    // use the globally available response()
    return response()->json([
        // ...
    ]);
});
```

## [Routing](https://laravel.com/docs/12.x/routing)

Routes are defined in:
- `routes/web.php` for web interface routes and have the `web` [middleware group](https://laravel.com/docs/12.x/middleware#laravels-default-middleware-groups)
- `routes/api.php` for stateless api routes and have the `api` [middleware group](https://laravel.com/docs/12.x/middleware#laravels-default-middleware-groups)

### Router Methods

Register routes to what HTTP verb they will respond to

```php
// Subdomain routing

// ORDER MATTERS
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

// Multiple HTTP verbs
Route::match(['get', 'post'], '/', function() {
  //...
});

// Any HTTP verb
Route::any('/', function () {

});

// Redirect
// cant use /destination and /status
Route::redirect('/here', '/there', /*optional*/ 301); //returns a 302 status code by default
Route::permanentRedirect('/here', '/there'); //returns 301 status code

// View
// return a view directly
Route::view('/welcome', 'welcome', /*optional*/ ['name' => 'Chris']);
```

### Basic Routes

- Parameters: URI and closure (anonymous function), callback (function used as argument)

```php
use Illuminate\Support\Facades\Route;
 
Route::get('/greeting', function () {
    return 'Hello World';
});
```

### API Routes

`routes/api.php`

```php
Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');
```

`/api` URI prefix is automatically applied to api routes
- change prefix in `bootstrap/app.php`

### Route Parameters

```php
Route::get('/user/{id}/{name?}', function (string $user_id, ?string $user_name = null) {
    return 'User '.$user_id;
});
```

### Constraints

Regular Expression Constraints
```php
// Constraints return 404 if pattern not matched
Route::get('/user/{name}', function (string $name) {
    // ...
})->where('name', '[A-Za-z]+');
 
Route::get('/user/{id}', function (string $id) {
    // ...
})->where('id', '[0-9]+');
 
Route::get('/user/{id}/{name}', function (string $id, string $name) {
    // ...
})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

// Convenient Helper methods
Route::get('/user/{id}/{name}', function (string $id, string $name) {
    // ...
})->whereNumber('id')->whereAlpha('name');
 
Route::get('/user/{name}', function (string $name) {
    // ...
})->whereAlphaNumeric('name');
 
Route::get('/user/{id}', function (string $id) {
    // ...
})->whereUuid('id');
 
Route::get('/user/{id}', function (string $id) {
    // ...
})->whereUlid('id');
 
Route::get('/category/{category}', function (string $category) {
    // ...
})->whereIn('category', ['movie', 'song', 'painting']);
 
Route::get('/category/{category}', function (string $category) {
    // ...
})->whereIn('category', CategoryEnum::cases());
```

Global Constraints
```php
// App\Providers\AppServiceProvider
use Illuminate\Support\Facades\Route;
 
/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Route::pattern('id', '[0-9]+');
}
```

Encoded Forward Slashes
```php
// explicitly allow / to be part of the placeholder 
Route::get('/search/{search}', function (string $search) {
    return $search;
})->where('search', '.*');
```

### Named Routes

`Route::...->name('profile')`

Route name's can be used for generating URLs or redirects

```php
// Generating URLs...
$url = route('profile', /*optional*/ ['id' => 1]);
 
// Generating Redirects...
return redirect()->route('profile');
 
return to_route('profile');


// Additional parameters
Route::get('/user/{id}/profile', function (string $id) {
    // ...
})->name('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']);
// http://example.com/user/1/profile?photos=yes
```

### Check current route

```php
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
 
/**
 * Handle an incoming request.
 *
 * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
 */
public function handle(Request $request, Closure $next): Response
{
    if ($request->route()->named('profile')) {
        // ...
    }
 
    return $next($request);
}
```

### [Route Groups](https://laravel.com/docs/12.x/routing#route-groups)

### Implicit Binding

Inject the model instance directly by matching the ID in the URI to the model

```php
use App\Models\User;
 
Route::get('/users/{user}', function (User $user) {
    return $user->email;
})->withTrashed() /*include to grab soft deleted models*/;

// or

use App\Http\Controllers\UserController;
use App\Models\User;
 
// Route definition...
Route::get('/users/{user}', [UserController::class, 'show']);
 
// Controller method definition...
public function show(User $user)
{
    return view('user.profile', ['user' => $user]);
}
```

Since `$user` type is `App\Models\User` and the variable name matches the `{user}` URI segment, Laravel will auto inject the model instance whose ID matches the value from the URI. Otherwise a 404 HTTP response will be generated.

You can choose which column to get model by besides `id`
```php
use App\Models\Post;
 
Route::get('/posts/{post:slug}', function (Post $post) {
    return $post;
});
```

Always use a database column other than `id`
```php
// inside Eloquent model
/**
 * Get the route key for the model.
 */
public function getRouteKeyName(): string
{
    return 'slug';
}
```

[Custom Keys and Scoping](https://laravel.com/docs/12.x/routing#implicit-model-binding-scoping) are useful for when you want to scope the other Eloquent models in the uri to be a child of the previous

[Customizing Missing Model Behavior](https://laravel.com/docs/12.x/routing#customizing-missing-model-behavior)

### [Explicit Binding](https://laravel.com/docs/12.x/routing#explicit-binding)

### [Rate Limiting](https://laravel.com/docs/12.x/routing#rate-limiting)

### Current Route

```php
use Illuminate\Support\Facades\Route;
 
$route = Route::current(); // Illuminate\Routing\Route
$name = Route::currentRouteName(); // string
$action = Route::currentRouteAction(); // string
```
### [Cross-Origin Resource Sharing (CORS)](https://laravel.com/docs/12.x/routing#cors)

[MDN web documentation on CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers)

### [Route Caching](https://laravel.com/docs/12.x/routing#route-caching)

## [Sanctum](https://laravel.com/docs/12.x/sanctum)

API token management and SPA Authentication

- SPA (ex. Next.js applications) dont need tokens of any kind
  - Uses Laravel's built-in cookie based session authentication services
  - First it will check for an authentication cookie, then it will examine the `Authorization` header for a valid API token. (don't have to use both features)
  - Must share the same top-level domain but can be different subdomain. Also, ensure you send the `Accept: application/json` header and either the `Referer` or `Origin` header with request
  
### [Issuing API Tokens](https://laravel.com/docs/12.x/sanctum#issuing-api-tokens)

### [Token abilities](https://laravel.com/docs/12.x/sanctum#token-abilities)

If the Sanctum's built-in SPA authentication passes, the token will be `tokenCan` will always return true.

However, the application's [authorization policies](https://laravel.com/docs/12.x/authorization#creating-policies) will determine if the token has the ability and if the user is allowed to perform the action

### Protecting Routes

Make sure all requests are authenticated from your first-party SPA or contain a valid API token header for third-parties
```php
use Illuminate\Http\Request;
 
Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');
```

## [Eloquent](https://laravel.com/docs/12.x/eloquent)

Laravel's object-relational mapper (ORM)

Each table has a corresponding "Model" which is used to read, insert, update, and delete records from the table.

### Select

[Query Builder](https://laravel.com/docs/12.x/queries)

```php
$flights = Flight::where('active', 1)
    ->orderBy('name')
    ->limit(10)
    ->get(); // SELECT
```

Queries returns a [Eloquent](https://laravel.com/docs/12.x/eloquent-collections#available-methods) - [Collection](https://laravel.com/docs/12.x/collections#available-methods)

[Retrieve or Create](https://laravel.com/docs/12.x/eloquent#retrieving-or-creating-models)

### Insert

Create a new model instance

```php
<?php
 
namespace App\Http\Controllers;
 
use App\Models\Flight;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
 
class FlightController extends Controller
{
    /**
     * Store a new flight in the database.
     */
    public function store(Request $request): RedirectResponse
    {
        // Validate the request...
 
        $flight = new Flight;
 
        $flight->name = $request->name;
 
        $flight->save(); // INSERT
 
        return redirect('/flights');
    }
}

// OR

use App\Models\Flight;
 
$flight = Flight::create([
    'name' => 'London to Paris',
]);

```

### Update

```php
use App\Models\Flight;
 
$flight = Flight::find(1);
 
$flight->name = 'Paris to London';
 
$flight->save();
```

`updateOrCreate`

[Mass Updates](https://laravel.com/docs/12.x/eloquent#mass-updates)

## DO Later

### [Database configuration](https://laravel.com/docs/12.x/database#configuration)


### [Authorization](https://laravel.com/docs/12.x/authorization#creating-policies)

# Web Applications

There are a few things you need to consider when building modern applications. Such as:

User Interface - how users will consume and interact with your application.
Routing - how users navigate between different parts of your application.
Data Fetching - where your data lives and how to get it.
Rendering - when and where you render static or dynamic content.
Integrations - what third-party services you use (for CMS, auth, payments, etc.) and how you connect to them.
Infrastructure - where you deploy, store, and run your application code (serverless, CDN, edge, etc.).
Performance - how to optimize your application for end-users.
Scalability - how your application adapts as your team, data, and traffic grow.
Developer Experience - your team's experience building and maintaining your application.

# [React](https://nextjs.org/learn/react-foundations)

Javascript library for SPA and UI

Building React app from scratch requires some effort (configuring tools and more). That's where Next.js comes in.

## How browsers render

1. User visits website
2. Browser asks web server for response
3. Server responds with HTML file
4. Browser converts HTML to DOM

Document Object Model
- tree-like structure with parent and child relationships
- HTML -> head -> nav
- ...  -> body -> p

In React, data flows down the component tree (one-way data flow) state can be passed from parent to child components as props

## Imperative vs Declarative Programming

React is a declarative library helps us tell the computer **what** we want to do instead of **how** to do something

> Imperative: how to do what you want done

> Declarative: what you want done

## JSX

JS extension that allows you to describe your UI in HTML-like syntax

Need JS compiler such as Babel to transform JSX -> JS

[Rules](https://react.dev/learn/writing-markup-with-jsx#the-rules-of-jsx)

## React Core Concepts

### Components

Function that returns UI elements

Used as building blocks of UI

ex. LEGO bricks

```js
function HomePage() {
  return (
    <div><Header /></div>
  )
}
//...
root.render(<HomePage />);
```

### Props

Properties are read-only info passed to components

ex. Like how `<img>` has `src` attribute or `<a>` has `href` attribute

Can pass any js expression (evaluates to a single value) through the jsx markup with `{ }`

```js
<Header title="React"/>
// leave prop as JS obj
function Header(props) {
  console.log(props); // { title: "React" }
  return <h1>Develop. Preview. Ship. {`Powered by ${props.title}`}</h1>; // can use template literal
}
// destructure object to explicitly name its values
function Header({title}) {
  console.log(title); // "React"
  return <h1>{title ? title: 'Default title'}</h1>
}
```

`key` prop
- React needs something to uniquely identify items in an array to know which elements to update in the DOM
- Recommended to use something guaranteed to be unique (ex. ID)

### Events

User interactions are events

Events are camelCased

[Adding Interactivity](https://react.dev/learn/adding-interactivitys)
[Managing State](https://react.dev/learn/managing-state)

### States

Any information in your UI that changes over time

Usually changed by user interaction

### Hooks

React functions (start with `use`) that add additional logic to components (ex. state)

#### `useState()`

```js

```

## Cheatsheet

```html
<script type="text/javascript">
    const app = document.getElementById('app');
    const root = ReactDOM.createRoot(app); // target a specific DOM element
    root.render(<h1>Develop. Preview. Ship. Powered by React.</h1>); // Render react code to DOM
</script>
```

# [Next.js](https://nextjs.org)

Framework for full-stack web applications with React

Handles the tooling and configuration needed for React. Also provides additional structure, features, and optimizations for a web app outside of setting up React.

Tools:
- React -> UI
- Next.js -> Routing, data fetching, caching, UX, DX

## Get started

1. create `package.json`
2. `$ npm install react@latest react-dom@latest next@latest`

## File Structure

`/app`
- routes
- components
- application logic

`/app/lib`
- libraries
  - utility functions
  - data fetching functions

`/app/ui`
- ui components

`/public`
- static assets (images, css, js)

## Routing

File-system routing

## Use React

Import React functions
`import { useState } from 'react';`

## Server vs Client Components

Client = web browser
- on user's side
- sends Request to server for application code
- receives Response and turns it into an interface the user can interact with

Server = computer that stores application code
- receives Requests from client
- sends Response with application code

Rendering and data fetching on server:
- improve performance by reducing amount of code sent to client

Interactive UI done one client side:
- some code needs to be on the client side

### Network Boundary

Choose where to place the separation between environments in your component tree

ex. Fetch and render a user's posts on server (using Server Components). Then render the interactive `LikeButton` for each post on the client (using Client Components).

If you want to show an active state, you need to render on the client side.

### Combining

After Server Components are rendered, a special data format called the React Server Component Payload (RSC) is sent to the client w/
1. the rendered result of Server Components
2. Placeholders (or holes) for where Client Components should be rendered and references to their JavaScript files